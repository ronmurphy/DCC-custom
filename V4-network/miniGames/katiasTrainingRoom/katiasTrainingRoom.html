<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Katia's Training Room</title>
    <meta name="description" content="Training simulation for Katia Grim - absorption and crossbow skills">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(45deg, #2c1810, #3d2817);
            color: white;
            overflow: hidden;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            border: 2px solid #654321;
            background: #2a2a2a;
            box-shadow: 0 0 20px rgba(139, 69, 19, 0.5);
        }

        #startMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #0f3460;
            z-index: 100;
        }

        #startMenu h1 {
            color: #4fc3f7;
            margin-bottom: 20px;
            font-size: 2.5rem;
            text-shadow: 0 0 10px #4fc3f7;
        }

        #startMenu p {
            margin: 10px 0;
            font-size: 1.2rem;
            color: #b0bec5;
        }

        #readyBtn {
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            border: none;
            padding: 15px 30px;
            font-size: 1.5rem;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        #readyBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(79, 195, 247, 0.5);
        }

        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 50;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #0f3460;
        }

        #gameUI div {
            margin: 5px 0;
            font-size: 1.2rem;
        }

        .score {
            color: #4fc3f7;
        }

        .mass {
            color: #81c784;
        }

        /* Virtual thumb stick styles */
        #thumbstickContainer {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 100px;
            height: 100px;
            z-index: 100;
            touch-action: none;
            display: none;
        }

        #thumbstickBase {
            position: absolute;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            left: 10px;
            top: 10px;
        }

        #thumbstickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(79, 195, 247, 0.7);
            border-radius: 50%;
            border: 2px solid #4fc3f7;
            transform: translate(-50%, -50%);
            left: 50%;
            top: 50%;
            transition: transform 0.1s;
        }

        /* Shoot button styles */
        #shootButton {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: linear-gradient(45deg, #ff6b6b, #ff5252);
            border-radius: 50%;
            border: 2px solid #ff9e9e;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            touch-action: none;
            display: none;
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
        }

        #shootButton::before {
            content: "";
            position: absolute;
            width: 30px;
            height: 5px;
            background: #333;
            border-radius: 3px;
            transform: rotate(45deg);
            top: 25px;
            left: 25px;
        }

        #shootButton::after {
            content: "";
            position: absolute;
            width: 30px;
            height: 5px;
            background: #333;
            border-radius: 3px;
            transform: rotate(-45deg);
            top: 25px;
            left: 25px;
        }

        #shootButton.active {
            background: linear-gradient(45deg, #ff5252, #ff1744);
            box-shadow: 0 0 20px rgba(255, 82, 82, 0.8);
        }

        /* Rush button */
        #rushButton {
            position: absolute;
            bottom: 25px;
            right: 100px;
            width: 70px;
            height: 70px;
            background: linear-gradient(45deg, #8A2BE2, #9932CC);
            border: 3px solid #DDA0DD;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            touch-action: none;
            display: none;
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.5);
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-align: center;
            line-height: 1;
        }

        #rushButton.active {
            background: linear-gradient(45deg, #FF69B4, #FF1493);
            box-shadow: 0 0 20px rgba(255, 105, 180, 0.8);
        }

        #rushButton.disabled {
            background: linear-gradient(45deg, #666666, #555555);
            border-color: #888888;
            box-shadow: 0 0 10px rgba(102, 102, 102, 0.3);
            opacity: 0.6;
        }

        #rushCooldownRing {
            position: absolute;
            top: -3px;
            left: -3px;
            width: 70px;
            height: 70px;
            border: 3px solid transparent;
            border-radius: 50%;
            background: conic-gradient(from 0deg, #8A2BE2 0%, #8A2BE2 var(--progress, 0%), transparent var(--progress, 0%));
            mask: radial-gradient(circle, transparent 60%, black 60%);
            -webkit-mask: radial-gradient(circle, transparent 60%, black 60%);
            pointer-events: none;
        }

        /* Desktop rush cooldown bar */
        #rushCooldownBar {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 8px;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #8A2BE2;
            border-radius: 5px;
            display: none;
        }

        #rushCooldownFill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to top, #8A2BE2, #DDA0DD);
            border-radius: 3px;
            height: var(--cooldown-progress, 0%);
            transition: height 0.1s ease;
        }

        /* Power-up notifications */
        .power-notification {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            z-index: 1000 !important;
            pointer-events: none !important;
            padding: 10px 15px !important;
            background: linear-gradient(45deg, #4fc3f7, #29b6f6) !important;
            color: white !important;
            border-radius: 5px !important;
            font-family: 'Courier New', monospace !important;
            font-size: 14px !important;
            font-weight: bold !important;
            box-shadow: 0 4px 12px rgba(79, 195, 247, 0.4) !important;
            border: 1px solid rgba(255, 255, 255, 0.3) !important;
            animation: slideInFade 3s ease-out forwards !important;
            min-width: 120px !important;
            text-align: center !important;
        }

        @keyframes slideInFade {
            0% { 
                transform: translateX(100px) !important;
                opacity: 0 !important;
            }
            20% { 
                transform: translateX(0) !important;
                opacity: 1 !important;
            }
            80% { 
                opacity: 1 !important;
            }
            100% { 
                opacity: 0 !important;
            }
        }

        @media (max-width: 768px) {
            #startMenu h1 {
                font-size: 2rem;
            }
            
            #startMenu p {
                font-size: 1rem;
            }
            
            #gameUI {
                font-size: 1rem;
            }
            
            #thumbstickContainer, #shootButton, #rushButton {
                display: block;
            }
            
            #rushCooldownBar {
                display: none;
            }
        }

        @media (min-width: 769px) {
            #rushCooldownBar {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="startMenu">
            <h1>KATIA'S TRAINING ROOM</h1>
            <p>ðŸŽ® Touch and drag to move</p>
            <p>ðŸ”µ Absorb energy orbs to grow stronger</p>
            <p>ðŸŽ¯ Some targets flee - use your crossbow!</p>
            <p>ðŸ“ˆ Master absorption techniques!</p>
            <button id="readyBtn">BEGIN TRAINING</button>
        </div>

        <div id="gameUI" style="display: none;">
            <div class="score">Score: <span id="score">0</span></div>
            <div class="mass">Mass: <span id="mass">10</span></div>
            <div class="room">Room: <span id="room">1</span></div>
            <div class="energy">Energy: <span id="energy">0</span>/<span id="energyRequired">100</span></div>
        </div>
        
        <!-- Virtual thumb stick -->
        <div id="thumbstickContainer">
            <div id="thumbstickBase"></div>
            <div id="thumbstickKnob"></div>
        </div>
        
        <!-- Shoot button -->
        <div id="shootButton"></div>
        
        <!-- Rush button -->
        <div id="rushButton">
            <div id="rushCooldownRing"></div>
            <span>RUSH</span>
        </div>
        
        <!-- Rush cooldown bar for desktop -->
        <div id="rushCooldownBar">
            <div id="rushCooldownFill"></div>
        </div>
    </div>

    <script>
        class MassCollectorGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.startMenu = document.getElementById('startMenu');
                this.gameUI = document.getElementById('gameUI');
                
                // Control elements
                this.thumbstickContainer = document.getElementById('thumbstickContainer');
                this.thumbstickKnob = document.getElementById('thumbstickKnob');
                this.shootButton = document.getElementById('shootButton');
                this.rushButton = document.getElementById('rushButton');
                this.rushCooldownRing = document.getElementById('rushCooldownRing');
                this.rushCooldownBar = document.getElementById('rushCooldownBar');
                this.rushCooldownFill = document.getElementById('rushCooldownFill');
                
                this.setupCanvas();
                this.initGame();
                this.setupControls();
                
                document.getElementById('readyBtn').addEventListener('click', () => this.startGame());
            }

            setupCanvas() {
                const container = document.getElementById('gameContainer');
                this.canvas.width = Math.min(window.innerWidth - 20, 800);
                this.canvas.height = Math.min(window.innerHeight - 20, 600);
                
                // Adjust for mobile
                if (window.innerWidth < 768) {
                    this.canvas.width = window.innerWidth - 10;
                    this.canvas.height = window.innerHeight - 10;
                }
            }

            showPowerNotification(mass, score, customMessage = null) {
                // Remove any existing notifications
                const existingNotifications = document.querySelectorAll('.power-notification');
                existingNotifications.forEach(notification => {
                    document.body.removeChild(notification);
                });

                // Create new notification
                const notification = document.createElement('div');
                notification.className = 'power-notification';
                
                let message = '';
                if (customMessage) {
                    message = customMessage;
                } else if (mass < 0) {
                    message = `DAMAGE! ${mass}`;
                } else if (mass >= 5) {
                    message = `MASS SURGE! +${Math.floor(mass)}`;
                } else if (score >= 50) {
                    message = `BIG SCORE! +${score}`;
                } else {
                    message = `ENERGY +${score}`;
                }
                
                notification.textContent = message;
                document.body.appendChild(notification);

                // Remove after animation completes
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 3000);
            }

            initGame() {
                this.gameStarted = false;
                this.gameRunning = false;
                
                // Player properties
                this.player = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    radius: 15,
                    mass: 10,
                    color: '#4fc3f7',
                    targetX: this.canvas.width / 2,
                    targetY: this.canvas.height / 2,
                    velocity: { x: 0, y: 0 },
                    maxSpeed: 5,
                    crossbowAngle: 0,
                    directionX: 1,  // Default to moving right
                    directionY: 0   // Initially not moving vertically
                };

                // Game state
                this.score = 0;
                this.collectibles = [];
                this.particles = [];
                this.projectiles = [];
                this.enemies = [];
                
                // Room progression
                this.currentRoom = 1;
                this.energyRequired = 100; // Energy needed to advance to next room
                this.totalEnergy = 0; // Total energy collected
                
                // Rush ability
                this.rushCooldown = 0; // Cooldown timer in milliseconds
                this.rushMaxCooldown = 30000; // 30 seconds
                this.rushActive = false;
                
                // Power-ups and effects
                this.powerUps = [];
                this.discoveredPowerUps = new Set(); // Track which colors have been discovered
                this.fireTrail = []; // Fire trail points for visual effect
                this.activeEffects = {
                    electricShield: { active: false, timer: 0 },
                    fireTrail: { active: false, timer: 0, trail: [] }
                };
                
                // Thumbstick properties
                this.thumbstickActive = false;
                this.thumbstickPosition = { x: 0, y: 0 };
                this.thumbstickBasePosition = { 
                    x: this.thumbstickContainer.offsetLeft + this.thumbstickContainer.offsetWidth / 2,
                    y: this.thumbstickContainer.offsetTop + this.thumbstickContainer.offsetHeight / 2
                };
                this.thumbstickRadius = 40;
                
                this.generateCollectibles();
                this.generateEnemies();
                this.generatePowerUps();
            }

            generateCollectibles() {
                this.collectibles = [];
                // DCC-themed energy crystal colors
                const colors = ['#8A2BE2', '#FF4500', '#32CD32', '#FFD700', '#DC143C', '#4169E1', '#FF69B4'];
                
                for (let i = 0; i < 25; i++) {
                    let x, y, attempts = 0;
                    
                    // Ensure collectibles don't spawn too close to player
                    do {
                        x = Math.random() * (this.canvas.width - 40) + 20;
                        y = Math.random() * (this.canvas.height - 40) + 20;
                        attempts++;
                    } while (
                        attempts < 50 && 
                        Math.sqrt((x - this.player.x) ** 2 + (y - this.player.y) ** 2) < 100
                    );

                    // Randomly make some collectibles flee
                    const isFleeing = Math.random() < 0.3;
                    
                    this.collectibles.push({
                        x: x,
                        y: y,
                        radius: Math.random() * 8 + 5,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        mass: Math.random() * 5 + 2,
                        pulse: Math.random() * Math.PI * 2,
                        collected: false,
                        fleeing: isFleeing,
                        fleeTimer: 0,
                        immobilized: false,
                        immobilizeTimer: 0
                    });
                }
            }

            generateEnemies() {
                this.enemies = [];
                const enemyCount = Math.min(3 + this.currentRoom, 8); // More enemies in higher rooms
                
                for (let i = 0; i < enemyCount; i++) {
                    let x, y, attempts = 0;
                    
                    // Spawn enemies away from player
                    do {
                        x = Math.random() * (this.canvas.width - 60) + 30;
                        y = Math.random() * (this.canvas.height - 60) + 30;
                        attempts++;
                    } while (
                        attempts < 50 && 
                        Math.sqrt((x - this.player.x) ** 2 + (y - this.player.y) ** 2) < 200
                    );
                    
                    // Different enemy types
                    const enemyType = Math.random();
                    let type, color, speed, health, behavior;
                    
                    if (enemyType < 0.4) {
                        // Chaser - direct pursuit
                        type = 'chaser';
                        color = '#FF4500'; // Orange-red
                        speed = 1.5;
                        health = 2;
                        behavior = 'chase';
                    } else if (enemyType < 0.7) {
                        // Ambusher - tries to flank
                        type = 'ambusher';
                        color = '#8B008B'; // Dark magenta
                        speed = 2;
                        health = 1;
                        behavior = 'flank';
                    } else {
                        // Guardian - protects crystals, slower but tougher
                        type = 'guardian';
                        color = '#2F4F4F'; // Dark slate gray
                        speed = 1;
                        health = 4;
                        behavior = 'guard';
                    }
                    
                    this.enemies.push({
                        x: x,
                        y: y,
                        radius: 12,
                        type: type,
                        color: color,
                        speed: speed,
                        health: health,
                        maxHealth: health,
                        behavior: behavior,
                        targetX: x,
                        targetY: y,
                        angle: 0,
                        stunned: false,
                        stunnedTimer: 0,
                        lastDamageTime: 0
                    });
                }
            }

            generatePowerUps() {
                this.powerUps = [];
                const powerUpCount = Math.min(2 + Math.floor(this.currentRoom / 3), 6); // More power-ups in higher rooms
                
                // Define power-up types
                const powerUpTypes = [
                    { type: 'electricShield', color: '#FFD700', name: 'Electric Shield' },
                    { type: 'fireTrail', color: '#FF4500', name: 'Fire Trail' },
                    { type: 'rushRefill', color: '#9932CC', name: 'Rush Refill' },
                    { type: 'healthBoost', color: '#00FF00', name: 'Health Boost' },
                    { type: 'crossbowUpgrade', color: '#00BFFF', name: 'Crossbow Upgrade' },
                    { type: 'massShield', color: '#C0C0C0', name: 'Mass Shield' }
                ];
                
                for (let i = 0; i < powerUpCount; i++) {
                    let x, y, attempts = 0;
                    
                    // Spawn power-ups away from player and enemies
                    do {
                        x = Math.random() * (this.canvas.width - 80) + 40;
                        y = Math.random() * (this.canvas.height - 80) + 40;
                        attempts++;
                    } while (
                        attempts < 50 && 
                        (Math.sqrt((x - this.player.x) ** 2 + (y - this.player.y) ** 2) < 150 ||
                         this.enemies.some(enemy => Math.sqrt((x - enemy.x) ** 2 + (y - enemy.y) ** 2) < 80))
                    );
                    
                    const powerUpType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                    
                    this.powerUps.push({
                        x: x,
                        y: y,
                        radius: 10,
                        type: powerUpType.type,
                        color: powerUpType.color,
                        name: powerUpType.name,
                        collected: false,
                        pulse: Math.random() * Math.PI * 2,
                        glowIntensity: 0
                    });
                }
            }

            setupControls() {
                // Touch controls for thumbstick
                this.thumbstickContainer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    this.thumbstickActive = true;
                    this.updateThumbstick(e.touches[0]);
                });

                this.thumbstickContainer.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning || !this.thumbstickActive) return;
                    
                    this.updateThumbstick(e.touches[0]);
                });

                this.thumbstickContainer.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.thumbstickActive = false;
                    this.resetThumbstick();
                });

                this.thumbstickContainer.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.thumbstickActive = false;
                    this.resetThumbstick();
                });

                // Shoot button controls
                this.shootButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    this.shootButton.classList.add('active');
                    this.shootCrossbow();
                });

                this.shootButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.shootButton.classList.remove('active');
                });

                this.shootButton.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.shootButton.classList.remove('active');
                });

                // Rush button controls
                this.rushButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning || this.rushCooldown > 0) return;
                    
                    this.rushButton.classList.add('active');
                    this.performRush();
                });

                this.rushButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.rushButton.classList.remove('active');
                });

                this.rushButton.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.rushButton.classList.remove('active');
                });

                // Mouse click to shoot for desktop
                this.canvas.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    if (e.button === 0) {
                        // Left click - shoot
                        this.shootCrossbow();
                    } else if (e.button === 2) {
                        // Right click - rush
                        if (this.rushCooldown <= 0) {
                            this.performRush();
                        }
                    }
                });

                // Disable context menu on right click
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });

                // Mouse controls for desktop
                this.canvas.addEventListener('mousemove', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    this.player.targetX = e.clientX - rect.left;
                    this.player.targetY = e.clientY - rect.top;
                });

                // Touch controls for canvas (fallback)
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    this.player.targetX = touch.clientX - rect.left;
                    this.player.targetY = touch.clientY - rect.top;
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    this.player.targetX = touch.clientX - rect.left;
                    this.player.targetY = touch.clientY - rect.top;
                });

                // Prevent context menu on touch
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            updateThumbstick(touch) {
                const rect = this.thumbstickContainer.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                // Calculate distance from center
                const centerX = this.thumbstickContainer.offsetWidth / 2;
                const centerY = this.thumbstickContainer.offsetHeight / 2;
                const dx = touchX - centerX;
                const dy = touchY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Limit to thumbstick radius
                if (distance > this.thumbstickRadius) {
                    const angle = Math.atan2(dy, dx);
                    this.thumbstickPosition.x = Math.cos(angle) * this.thumbstickRadius;
                    this.thumbstickPosition.y = Math.sin(angle) * this.thumbstickRadius;
                } else {
                    this.thumbstickPosition.x = dx;
                    this.thumbstickPosition.y = dy;
                }
                
                // Update knob position
                this.thumbstickKnob.style.transform = `translate(-50%, -50%) translate(${this.thumbstickPosition.x}px, ${this.thumbstickPosition.y}px)`;
                
                // Update player target position based on thumbstick
                const maxDistance = this.thumbstickRadius;
                const moveX = this.thumbstickPosition.x / maxDistance;
                const moveY = this.thumbstickPosition.y / maxDistance;
                
                this.player.targetX = this.player.x + moveX * 100;
                this.player.targetY = this.player.y + moveY * 100;
            }
            
            resetThumbstick() {
                this.thumbstickPosition = { x: 0, y: 0 };
                this.thumbstickKnob.style.transform = 'translate(-50%, -50%)';
                this.player.targetX = this.player.x;
                this.player.targetY = this.player.y;
            }
            
            updateCrossbowDirection() {
                this.player.crossbowAngle = Math.atan2(this.player.directionY, this.player.directionX);
            }
            
            shootCrossbow() {
                if (!this.gameRunning) return;
                
                // Create a projectile
                const speed = 10;
                const offsetX = Math.cos(this.player.crossbowAngle) * (this.player.radius + 5);
                const offsetY = Math.sin(this.player.crossbowAngle) * (this.player.radius + 5);
                
                this.projectiles.push({
                    x: this.player.x + offsetX,
                    y: this.player.y + offsetY,
                    vx: Math.cos(this.player.crossbowAngle) * speed,
                    vy: Math.sin(this.player.crossbowAngle) * speed,
                    radius: 4,
                    color: '#ffcc00',
                    life: 60 // Will disappear after 60 frames
                });
            }

            performRush() {
                if (this.rushCooldown > 0) return;
                
                // Start cooldown
                this.rushCooldown = this.rushMaxCooldown;
                this.updateRushButton();
                
                // Random rush distance - anywhere from 20 pixels to edge of screen
                const direction = this.player.directionX;
                const minDistance = 20;
                const maxDistance = Math.min(
                    this.canvas.width - this.player.x - this.player.radius,
                    this.player.x - this.player.radius,
                    200 // Cap at reasonable distance
                );
                const rushDistance = Math.random() * (maxDistance - minDistance) + minDistance;
                
                // Rush in the direction Katia was last moving (or forward)
                const rushAngle = Math.atan2(this.player.directionY, this.player.directionX);
                const endX = this.player.x + Math.cos(rushAngle) * rushDistance;
                const endY = this.player.y + Math.sin(rushAngle) * rushDistance;
                
                // Keep within bounds
                const finalX = Math.max(this.player.radius, Math.min(this.canvas.width - this.player.radius, endX));
                const finalY = Math.max(this.player.radius, Math.min(this.canvas.height - this.player.radius, endY));
                
                // Create rush trail effect
                this.createRushTrail(this.player.x, this.player.y, finalX, finalY);
                
                // Check for absorption during rush
                this.checkRushCollisions(this.player.x, this.player.y, finalX, finalY);
                
                // Move player instantly
                this.player.x = finalX;
                this.player.y = finalY;
                this.player.targetX = finalX;
                this.player.targetY = finalY;
                
                // Show rush notification
                this.showPowerNotification(0, 0, `RUSH! Distance: ${Math.floor(rushDistance)}px`);
            }

            createRushTrail(startX, startY, endX, endY) {
                // Create purple energy trail particles
                const steps = 10;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const x = startX + (endX - startX) * t;
                    const y = startY + (endY - startY) * t;
                    
                    // Add multiple particles per step for thick trail
                    for (let j = 0; j < 3; j++) {
                        this.particles.push({
                            x: x + (Math.random() - 0.5) * 10,
                            y: y + (Math.random() - 0.5) * 10,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            color: '#8A2BE2',
                            life: 30,
                            maxLife: 30
                        });
                    }
                }
            }

            checkRushCollisions(startX, startY, endX, endY) {
                // Check what Katia hits during her rush
                const dx = endX - startX;
                const dy = endY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const steps = Math.ceil(distance / 5); // Check every 5 pixels
                
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const checkX = startX + dx * t;
                    const checkY = startY + dy * t;
                    
                    // Check collectibles
                    this.collectibles.forEach((collectible, index) => {
                        if (collectible.collected) return;
                        
                        const cdx = checkX - collectible.x;
                        const cdy = checkY - collectible.y;
                        const cdist = Math.sqrt(cdx * cdx + cdy * cdy);
                        
                        if (cdist < this.player.radius + collectible.radius) {
                            // Absorb during rush!
                            collectible.collected = true;
                            const scoreGain = Math.floor(collectible.mass * 15); // Bonus for rush absorption
                            const energyGain = Math.floor(collectible.mass * 8);
                            this.score += scoreGain;
                            this.totalEnergy += energyGain;
                            this.player.mass += collectible.mass;
                            this.player.radius = Math.sqrt(this.player.mass) * 2;
                            
                            // Create absorption particles
                            this.createParticles(collectible.x, collectible.y, collectible.color);
                            this.collectibles.splice(index, 1);
                        }
                    });
                    
                    // Check enemies - Rush damages them!
                    this.enemies.forEach((enemy, index) => {
                        const edx = checkX - enemy.x;
                        const edy = checkY - enemy.y;
                        const edist = Math.sqrt(edx * edx + edy * edy);
                        
                        if (edist < this.player.radius + enemy.radius) {
                            // Rush damages enemies
                            enemy.health -= 2;
                            enemy.lastDamageTime = Date.now();
                            
                            // Create hit particles
                            this.createParticles(enemy.x, enemy.y, '#ff0000');
                            
                            if (enemy.health <= 0) {
                                // Enemy defeated by rush
                                this.score += 75; // Bonus for rush kill
                                this.createParticles(enemy.x, enemy.y, enemy.color);
                                this.enemies.splice(index, 1);
                            } else {
                                // Knock back enemy
                                const knockAngle = Math.atan2(edy, edx);
                                enemy.x += Math.cos(knockAngle) * 30;
                                enemy.y += Math.sin(knockAngle) * 30;
                                enemy.stunned = true;
                                enemy.stunnedTimer = 90; // 1.5 seconds
                            }
                        }
                    });
                }
            }

            updatePlayer() {
                const dx = this.player.targetX - this.player.x;
                const dy = this.player.targetY - this.player.y;
                
                // Calculate direction and distance
                const distance = Math.sqrt(dx * dx + dy * dy);
                const directionX = dx / distance || 0;
                const directionY = dy / distance || 0;
                
                // Store movement direction (if moving significantly)
                if (distance > 5) {
                    this.player.directionX = directionX;
                    this.player.directionY = directionY;
                }
                
                // Smooth movement with speed based on mass
                const speed = Math.max(0.5, 3 - (this.player.mass / 50));
                this.player.x += directionX * speed;
                this.player.y += directionY * speed;

                // Keep player in bounds
                this.player.x = Math.max(this.player.radius, 
                    Math.min(this.canvas.width - this.player.radius, this.player.x));
                this.player.y = Math.max(this.player.radius, 
                    Math.min(this.canvas.height - this.player.radius, this.player.y));
            }

            updateCollectibles() {
                this.collectibles.forEach(collectible => {
                    if (collectible.collected || collectible.immobilized) return;
                    
                    // Update flee timer if active
                    if (collectible.fleeTimer > 0) {
                        collectible.fleeTimer--;
                    }
                    
                    // Fleeing behavior
                    if (collectible.fleeing && collectible.fleeTimer <= 0) {
                        const dx = collectible.x - this.player.x;
                        const dy = collectible.y - this.player.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Only flee if player is close enough
                        if (distance < 150) {
                            const fleeSpeed = 0.8;
                            const fleeDirectionX = dx / distance;
                            const fleeDirectionY = dy / distance;
                            
                            collectible.x += fleeDirectionX * fleeSpeed;
                            collectible.y += fleeDirectionY * fleeSpeed;
                            
                            // Keep collectible in bounds
                            collectible.x = Math.max(collectible.radius, 
                                Math.min(this.canvas.width - collectible.radius, collectible.x));
                            collectible.y = Math.max(collectible.radius, 
                                Math.min(this.canvas.height - collectible.radius, collectible.y));
                        }
                    }
                });
            }
            
            updateProjectiles() {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const projectile = this.projectiles[i];
                    
                    // Move projectile
                    projectile.x += projectile.vx;
                    projectile.y += projectile.vy;
                    projectile.life--;
                    
                    // Check if projectile is out of bounds
                    if (
                        projectile.x < -50 || 
                        projectile.x > this.canvas.width + 50 ||
                        projectile.y < -50 || 
                        projectile.y > this.canvas.height + 50 ||
                        projectile.life <= 0
                    ) {
                        this.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // Check collision with collectibles
                    this.collectibles.forEach(collectible => {
                        if (collectible.collected || collectible.immobilized) return;
                        
                        const dx = projectile.x - collectible.x;
                        const dy = projectile.y - collectible.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < projectile.radius + collectible.radius) {
                            // Hit! Immobilize the collectible
                            collectible.immobilized = true;
                            collectible.immobilizeTimer = 120; // 2 seconds at 60fps
                            
                            // Create hit particles
                            this.createParticles(collectible.x, collectible.y, '#ffcc00');
                            
                            // Remove projectile
                            this.projectiles.splice(i, 1);
                            return;
                        }
                    });
                }
            }

            updateEnemies() {
                this.enemies.forEach((enemy, index) => {
                    // Handle stun timer
                    if (enemy.stunned) {
                        enemy.stunnedTimer--;
                        if (enemy.stunnedTimer <= 0) {
                            enemy.stunned = false;
                        }
                        return; // Don't move while stunned
                    }
                    
                    // Different AI behaviors
                    if (enemy.behavior === 'chase') {
                        // Direct chase
                        const dx = this.player.x - enemy.x;
                        const dy = this.player.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            enemy.x += (dx / distance) * enemy.speed;
                            enemy.y += (dy / distance) * enemy.speed;
                        }
                    } else if (enemy.behavior === 'flank') {
                        // Try to move to player's side
                        const dx = this.player.x - enemy.x;
                        const dy = this.player.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 50) {
                            // Move toward player
                            enemy.x += (dx / distance) * enemy.speed;
                            enemy.y += (dy / distance) * enemy.speed;
                        } else {
                            // Circle around player
                            const angle = Math.atan2(dy, dx) + Math.PI / 2;
                            enemy.x += Math.cos(angle) * enemy.speed;
                            enemy.y += Math.sin(angle) * enemy.speed;
                        }
                    } else if (enemy.behavior === 'guard') {
                        // Protect nearest crystal cluster
                        let nearestCrystal = null;
                        let nearestDistance = Infinity;
                        
                        this.collectibles.forEach(collectible => {
                            if (!collectible.collected) {
                                const dist = Math.sqrt((enemy.x - collectible.x) ** 2 + (enemy.y - collectible.y) ** 2);
                                if (dist < nearestDistance) {
                                    nearestDistance = dist;
                                    nearestCrystal = collectible;
                                }
                            }
                        });
                        
                        if (nearestCrystal) {
                            const playerDist = Math.sqrt((this.player.x - nearestCrystal.x) ** 2 + (this.player.y - nearestCrystal.y) ** 2);
                            const enemyDist = Math.sqrt((enemy.x - nearestCrystal.x) ** 2 + (enemy.y - nearestCrystal.y) ** 2);
                            
                            if (playerDist < 100 && enemyDist > 30) {
                                // Player near crystal, move to intercept
                                const dx = this.player.x - enemy.x;
                                const dy = this.player.y - enemy.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance > 0) {
                                    enemy.x += (dx / distance) * enemy.speed;
                                    enemy.y += (dy / distance) * enemy.speed;
                                }
                            } else if (enemyDist > 40) {
                                // Move closer to crystal
                                const dx = nearestCrystal.x - enemy.x;
                                const dy = nearestCrystal.y - enemy.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance > 0) {
                                    enemy.x += (dx / distance) * enemy.speed * 0.5;
                                    enemy.y += (dy / distance) * enemy.speed * 0.5;
                                }
                            }
                        }
                    }
                    
                    // Keep enemies in bounds
                    enemy.x = Math.max(enemy.radius, Math.min(this.canvas.width - enemy.radius, enemy.x));
                    enemy.y = Math.max(enemy.radius, Math.min(this.canvas.height - enemy.radius, enemy.y));
                });
            }

            checkEnemyCollisions() {
                // Check projectile hits on enemies
                this.projectiles.forEach((projectile, projIndex) => {
                    this.enemies.forEach((enemy, enemyIndex) => {
                        if (enemy.stunned) return;
                        
                        const dx = projectile.x - enemy.x;
                        const dy = projectile.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < projectile.radius + enemy.radius) {
                            // Hit enemy with crossbow
                            enemy.health--;
                            enemy.lastDamageTime = Date.now();
                            
                            // Create hit particles
                            this.createParticles(enemy.x, enemy.y, '#ff0000');
                            
                            // Remove projectile
                            this.projectiles.splice(projIndex, 1);
                            
                            if (enemy.health <= 0) {
                                // Enemy defeated
                                this.score += 50;
                                this.createParticles(enemy.x, enemy.y, enemy.color);
                                this.enemies.splice(enemyIndex, 1);
                            } else {
                                // Stun enemy briefly
                                enemy.stunned = true;
                                enemy.stunnedTimer = 30; // 0.5 seconds
                            }
                            return;
                        }
                    });
                });
                
                // Check player collision with enemies
                this.enemies.forEach((enemy, index) => {
                    const dx = this.player.x - enemy.x;
                    const dy = this.player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.player.radius + enemy.radius) {
                        // Player touched by enemy - take damage
                        this.player.mass = Math.max(5, this.player.mass - 2);
                        this.player.radius = Math.sqrt(this.player.mass) * 2;
                        
                        // Push enemy away
                        const pushForce = 20;
                        const angle = Math.atan2(dy, dx);
                        enemy.x -= Math.cos(angle) * pushForce;
                        enemy.y -= Math.sin(angle) * pushForce;
                        
                        // Brief stun for enemy
                        enemy.stunned = true;
                        enemy.stunnedTimer = 60; // 1 second
                        
                        // Damage notification
                        this.showPowerNotification(-2, -20);
                    }
                });
            }
            
            updateImmobilizedCollectibles() {
                this.collectibles.forEach(collectible => {
                    if (collectible.immobilized) {
                        collectible.immobilizeTimer--;
                        
                        if (collectible.immobilizeTimer <= 0) {
                            collectible.immobilized = false;
                        }
                    }
                });
            }

            checkCollisions() {
                this.collectibles.forEach((collectible, index) => {
                    if (collectible.collected) return;

                    const dx = this.player.x - collectible.x;
                    const dy = this.player.y - collectible.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.player.radius + collectible.radius) {
                        // Collect the item
                        collectible.collected = true;
                        const scoreGain = Math.floor(collectible.mass * 10);
                        const energyGain = Math.floor(collectible.mass * 5);
                        this.score += scoreGain;
                        this.totalEnergy += energyGain;
                        this.player.mass += collectible.mass;
                        this.player.radius = Math.sqrt(this.player.mass) * 2;

                        // Show power-up notification
                        this.showPowerNotification(collectible.mass, scoreGain);

                        // Create particles
                        this.createParticles(collectible.x, collectible.y, collectible.color);

                        // Remove collectible
                        this.collectibles.splice(index, 1);

                        // Generate new collectible
                        if (this.collectibles.length < 20) {
                            setTimeout(() => this.addNewCollectible(), 500);
                        }
                    }
                });
            }

            addNewCollectible() {
                // DCC-themed energy crystal colors
                const colors = ['#8A2BE2', '#FF4500', '#32CD32', '#FFD700', '#DC143C', '#4169E1', '#FF69B4'];
                let x, y, attempts = 0;
                
                do {
                    x = Math.random() * (this.canvas.width - 40) + 20;
                    y = Math.random() * (this.canvas.height - 40) + 20;
                    attempts++;
                } while (
                    attempts < 50 && 
                    Math.sqrt((x - this.player.x) ** 2 + (y - this.player.y) ** 2) < 150
                );

                // Randomly make some collectibles flee
                const isFleeing = Math.random() < 0.3;
                
                this.collectibles.push({
                    x: x,
                    y: y,
                    radius: Math.random() * 8 + 5,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    mass: Math.random() * 5 + 2,
                    pulse: Math.random() * Math.PI * 2,
                    collected: false,
                    fleeing: isFleeing,
                    fleeTimer: 0,
                    immobilized: false,
                    immobilizeTimer: 0
                });
            }

            createParticles(x, y, color) {
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        color: color,
                        life: 30,
                        maxLife: 30
                    });
                }
            }

            updateParticles() {
                this.particles.forEach((particle, index) => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.98;
                    particle.vy *= 0.98;
                    particle.life--;

                    if (particle.life <= 0) {
                        this.particles.splice(index, 1);
                    }
                });
            }

            drawStoneFloor() {
                const tileSize = 60;
                for (let x = 0; x < this.canvas.width + tileSize; x += tileSize) {
                    for (let y = 0; y < this.canvas.height + tileSize; y += tileSize) {
                        // Draw stone tile
                        this.ctx.fillStyle = '#3a3a3a';
                        this.ctx.fillRect(x, y, tileSize - 2, tileSize - 2);
                        
                        // Add some variation to tiles
                        const variation = Math.sin(x * 0.01 + y * 0.01) * 10;
                        this.ctx.fillStyle = `rgba(${50 + variation}, ${50 + variation}, ${50 + variation}, 0.3)`;
                        this.ctx.fillRect(x + 5, y + 5, tileSize - 12, tileSize - 12);
                        
                        // Dark grout lines
                        this.ctx.strokeStyle = '#1a1a1a';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(x, y, tileSize - 2, tileSize - 2);
                    }
                }
            }

            render() {
                // Clear canvas with dark stone color
                this.ctx.fillStyle = '#2a2a2a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw stone floor tiles
                this.drawStoneFloor();

                // Draw grid
                this.ctx.strokeStyle = 'rgba(15, 52, 96, 0.3)';
                this.ctx.lineWidth = 1;
                for (let x = 0; x < this.canvas.width; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let y = 0; y < this.canvas.height; y += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }

                // Draw projectiles
                this.projectiles.forEach(projectile => {
                    this.ctx.beginPath();
                    this.ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = projectile.color;
                    this.ctx.fill();
                    
                    // Draw bolt tail
                    this.ctx.beginPath();
                    this.ctx.moveTo(projectile.x, projectile.y);
                    this.ctx.lineTo(
                        projectile.x - Math.cos(this.player.crossbowAngle) * 10,
                        projectile.y - Math.sin(this.player.crossbowAngle) * 10
                    );
                    this.ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });

                // Draw collectibles (Energy Crystals)
                this.collectibles.forEach(collectible => {
                    if (collectible.collected) return;
                    
                    this.drawEnergyCrystal(collectible);
                });

                // Draw enemies
                this.enemies.forEach(enemy => {
                    this.drawEnemy(enemy);
                });

                // Draw power-ups
                this.powerUps.forEach(powerUp => {
                    this.drawPowerUp(powerUp);
                });

                // Draw particles
                this.particles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.fillStyle = particle.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, 3 * alpha, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // Draw player (Katia/Tatis)
                this.drawKatiaSprite();
                
                // Draw active power-up effects
                this.drawActiveEffects();
                
                // Draw crossbow
                this.drawCrossbow();
            }

            drawKatiaSprite() {
                const x = this.player.x;
                const y = this.player.y;
                const radius = this.player.radius;
                
                // Draw muscular body (larger, darker skin tone)
                this.ctx.fillStyle = '#8B4513'; // Dark skin tone
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius * 0.9, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw body highlight for muscle definition
                this.ctx.fillStyle = '#A0522D';
                this.ctx.beginPath();
                this.ctx.arc(x - radius * 0.3, y - radius * 0.3, radius * 0.4, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw purple mohawk (distinctive purple hair in spikes)
                this.ctx.fillStyle = '#8A2BE2'; // Purple
                this.ctx.beginPath();
                // Central spike
                this.ctx.arc(x, y - radius * 0.8, radius * 0.3, 0, Math.PI * 2);
                this.ctx.fill();
                // Left spike
                this.ctx.beginPath();
                this.ctx.arc(x - radius * 0.4, y - radius * 0.7, radius * 0.25, 0, Math.PI * 2);
                this.ctx.fill();
                // Right spike
                this.ctx.beginPath();
                this.ctx.arc(x + radius * 0.4, y - radius * 0.7, radius * 0.25, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw energy aura (represents her absorption powers)
                this.ctx.strokeStyle = 'rgba(138, 43, 226, 0.5)'; // Purple glow
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius + 5, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Pulsing inner aura
                const pulseSize = Math.sin(Date.now() * 0.005) * 3;
                this.ctx.strokeStyle = 'rgba(138, 43, 226, 0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius + pulseSize, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            drawCrossbow() {
                const x = this.player.x;
                const y = this.player.y;
                const angle = this.player.crossbowAngle;
                const length = this.player.radius + 12;
                
                // Crossbow stock (main body)
                this.ctx.strokeStyle = '#8B4513'; // Dark brown
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(
                    x + Math.cos(angle) * length,
                    y + Math.sin(angle) * length
                );
                this.ctx.stroke();
                
                // Crossbow arms (horizontal part)
                const armLength = 8;
                const tipX = x + Math.cos(angle) * length;
                const tipY = y + Math.sin(angle) * length;
                
                // Left arm
                this.ctx.strokeStyle = '#654321'; // Darker brown
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(
                    tipX + Math.cos(angle + Math.PI/2) * armLength,
                    tipY + Math.sin(angle + Math.PI/2) * armLength
                );
                this.ctx.lineTo(
                    tipX + Math.cos(angle - Math.PI/2) * armLength,
                    tipY + Math.sin(angle - Math.PI/2) * armLength
                );
                this.ctx.stroke();
                
                // Crossbow string
                this.ctx.strokeStyle = 'rgba(200, 200, 200, 0.8)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(
                    tipX + Math.cos(angle + Math.PI/2) * armLength * 0.8,
                    tipY + Math.sin(angle + Math.PI/2) * armLength * 0.8
                );
                this.ctx.lineTo(
                    tipX + Math.cos(angle - Math.PI/2) * armLength * 0.8,
                    tipY + Math.sin(angle - Math.PI/2) * armLength * 0.8
                );
                this.ctx.stroke();
                
                // Trigger mechanism
                this.ctx.fillStyle = '#CD853F'; // Light brown
                this.ctx.beginPath();
                this.ctx.arc(
                    x + Math.cos(angle) * (length * 0.7),
                    y + Math.sin(angle) * (length * 0.7),
                    2,
                    0,
                    Math.PI * 2
                );
                this.ctx.fill();
            }

            drawEnergyCrystal(collectible) {
                const x = collectible.x;
                const y = collectible.y;
                collectible.pulse += 0.1;
                const pulseIntensity = Math.sin(collectible.pulse) * 0.3 + 0.7;
                const radius = collectible.radius;
                
                // Draw crystal facets (diamond-like shape)
                this.ctx.save();
                this.ctx.translate(x, y);
                
                // Main crystal body
                this.ctx.fillStyle = collectible.color;
                this.ctx.globalAlpha = pulseIntensity;
                this.ctx.beginPath();
                // Create diamond/crystal shape
                this.ctx.moveTo(0, -radius);
                this.ctx.lineTo(radius * 0.7, -radius * 0.3);
                this.ctx.lineTo(radius * 0.7, radius * 0.3);
                this.ctx.lineTo(0, radius);
                this.ctx.lineTo(-radius * 0.7, radius * 0.3);
                this.ctx.lineTo(-radius * 0.7, -radius * 0.3);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Crystal highlights
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                this.ctx.globalAlpha = pulseIntensity * 0.8;
                this.ctx.beginPath();
                this.ctx.moveTo(0, -radius * 0.8);
                this.ctx.lineTo(radius * 0.4, -radius * 0.2);
                this.ctx.lineTo(0, 0);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Energy glow
                this.ctx.globalAlpha = pulseIntensity * 0.5;
                this.ctx.strokeStyle = collectible.color;
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, radius + 3, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Immobilized effect (crossbow hit)
                if (collectible.immobilized) {
                    this.ctx.globalAlpha = 1;
                    this.ctx.strokeStyle = 'rgba(255, 204, 0, 0.9)';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius + 5, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Draw crossbow bolt stuck in crystal
                    this.ctx.strokeStyle = '#8B4513';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(-radius * 0.3, -radius * 0.3);
                    this.ctx.lineTo(radius * 0.3, radius * 0.3);
                    this.ctx.stroke();
                }
                
                this.ctx.restore();
            }

            drawEnemy(enemy) {
                const x = enemy.x;
                const y = enemy.y;
                const radius = enemy.radius;
                
                // Flash red when damaged
                const timeSinceHit = Date.now() - enemy.lastDamageTime;
                const isFlashing = timeSinceHit < 300 && Math.floor(timeSinceHit / 50) % 2 === 0;
                
                this.ctx.save();
                this.ctx.translate(x, y);
                
                // Main enemy body based on type
                if (enemy.type === 'chaser') {
                    // Aggressive angular shape
                    this.ctx.fillStyle = isFlashing ? '#FF6666' : enemy.color;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, -radius);
                    this.ctx.lineTo(radius * 0.8, -radius * 0.3);
                    this.ctx.lineTo(radius * 0.8, radius * 0.3);
                    this.ctx.lineTo(0, radius);
                    this.ctx.lineTo(-radius * 0.8, radius * 0.3);
                    this.ctx.lineTo(-radius * 0.8, -radius * 0.3);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // Aggressive eyes
                    this.ctx.fillStyle = '#FF0000';
                    this.ctx.beginPath();
                    this.ctx.arc(-radius * 0.3, -radius * 0.2, 2, 0, Math.PI * 2);
                    this.ctx.arc(radius * 0.3, -radius * 0.2, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                } else if (enemy.type === 'ambusher') {
                    // Sleek, fast shape
                    this.ctx.fillStyle = isFlashing ? '#DD44DD' : enemy.color;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Speed lines
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    this.ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        const angle = (i * Math.PI * 2) / 3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(Math.cos(angle) * radius * 0.5, Math.sin(angle) * radius * 0.5);
                        this.ctx.lineTo(Math.cos(angle) * radius * 0.8, Math.sin(angle) * radius * 0.8);
                        this.ctx.stroke();
                    }
                    
                } else if (enemy.type === 'guardian') {
                    // Heavy, defensive shape
                    this.ctx.fillStyle = isFlashing ? '#666666' : enemy.color;
                    this.ctx.fillRect(-radius, -radius * 0.8, radius * 2, radius * 1.6);
                    
                    // Armor plating
                    this.ctx.strokeStyle = '#888888';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(-radius, -radius * 0.8, radius * 2, radius * 1.6);
                    
                    // Shield symbol
                    this.ctx.strokeStyle = '#AAAAAA';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius * 0.4, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                // Health bar
                if (enemy.health < enemy.maxHealth) {
                    const barWidth = radius * 2;
                    const barHeight = 4;
                    const healthPercent = enemy.health / enemy.maxHealth;
                    
                    // Background
                    this.ctx.fillStyle = '#333333';
                    this.ctx.fillRect(-barWidth / 2, -radius - 10, barWidth, barHeight);
                    
                    // Health
                    this.ctx.fillStyle = '#FF0000';
                    this.ctx.fillRect(-barWidth / 2, -radius - 10, barWidth * healthPercent, barHeight);
                }
                
                // Stun effect
                if (enemy.stunned) {
                    this.ctx.strokeStyle = '#FFFF00';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius + 3, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Stun stars
                    for (let i = 0; i < 3; i++) {
                        const angle = (Date.now() * 0.01 + i * Math.PI * 2 / 3);
                        const starX = Math.cos(angle) * (radius + 8);
                        const starY = Math.sin(angle) * (radius + 8);
                        this.ctx.fillStyle = '#FFFF00';
                        this.ctx.beginPath();
                        this.ctx.arc(starX, starY, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
                
                this.ctx.restore();
            }

            drawPowerUp(powerUp) {
                const x = powerUp.x;
                const y = powerUp.y;
                powerUp.pulse += 0.1;
                const pulseIntensity = Math.sin(powerUp.pulse) * 0.3 + 0.7;
                const radius = powerUp.radius;
                
                this.ctx.save();
                this.ctx.translate(x, y);
                
                // Draw diamond/scroll shape based on type
                this.ctx.fillStyle = powerUp.color;
                this.ctx.globalAlpha = pulseIntensity;
                
                if (powerUp.type === 'rush-refill' || powerUp.type === 'electric-shield' || powerUp.type === 'mass-shield') {
                    // Draw scroll shape for special abilities
                    this.ctx.fillRect(-radius * 0.8, -radius * 0.6, radius * 1.6, radius * 1.2);
                    this.ctx.fillStyle = powerUp.color;
                    this.ctx.globalAlpha = pulseIntensity * 0.7;
                    this.ctx.fillRect(-radius * 0.6, -radius * 0.4, radius * 1.2, radius * 0.8);
                } else {
                    // Draw diamond shape for consumables
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, -radius);
                    this.ctx.lineTo(radius * 0.7, 0);
                    this.ctx.lineTo(0, radius);
                    this.ctx.lineTo(-radius * 0.7, 0);
                    this.ctx.closePath();
                    this.ctx.fill();
                }
                
                // Add glowing effect
                this.ctx.globalAlpha = pulseIntensity * 0.5;
                this.ctx.shadowColor = powerUp.color;
                this.ctx.shadowBlur = 10;
                this.ctx.fillStyle = powerUp.color;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, radius * 0.5, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.restore();
            }

            drawActiveEffects() {
                // Draw Electric Shield effect
                if (this.activeEffects.electricShield.active) {
                    const x = this.player.x;
                    const y = this.player.y;
                    const radius = this.activeEffects.electricShield.radius;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.strokeStyle = '#00FFFF';
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Electric sparks
                    for (let i = 0; i < 8; i++) {
                        const angle = (Date.now() * 0.01 + i * Math.PI / 4);
                        const sparkX = x + Math.cos(angle) * radius;
                        const sparkY = y + Math.sin(angle) * radius;
                        this.ctx.fillStyle = '#00FFFF';
                        this.ctx.globalAlpha = 0.7;
                        this.ctx.beginPath();
                        this.ctx.arc(sparkX, sparkY, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    this.ctx.restore();
                }
                
                // Draw Fire Trail
                this.fireTrail.forEach((point, index) => {
                    const alpha = point.life / point.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha * 0.8;
                    this.ctx.fillStyle = `hsl(${Math.random() * 60}, 100%, 50%)`; // Random reds/oranges
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, 4 * alpha, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('mass').textContent = Math.floor(this.player.mass);
                document.getElementById('room').textContent = this.currentRoom;
                document.getElementById('energy').textContent = this.totalEnergy;
                document.getElementById('energyRequired').textContent = this.energyRequired;
                
                // Check for room advancement
                if (this.totalEnergy >= this.energyRequired) {
                    this.advanceToNextRoom();
                }
            }

            advanceToNextRoom() {
                this.currentRoom++;
                this.energyRequired = Math.floor(this.energyRequired * 1.5); // Increase requirement by 50%
                this.totalEnergy = 0; // Reset energy for new room
                
                // Show room advancement notification
                this.showPowerNotification(0, 0, `ROOM ${this.currentRoom} UNLOCKED!`);
                
                // Generate new enemies and collectibles for the new room
                this.generateEnemies();
                this.generateCollectibles();
                this.generatePowerUps();
                
                // Slight player power boost for advancing
                this.player.mass += 5;
                this.player.radius = Math.sqrt(this.player.mass) * 2;
            }

            updateRushCooldown() {
                if (this.rushCooldown > 0) {
                    this.rushCooldown -= 16; // Assuming ~60fps (16ms per frame)
                    if (this.rushCooldown < 0) {
                        this.rushCooldown = 0;
                    }
                    this.updateRushButton();
                }
            }

            updateRushButton() {
                const progress = (this.rushMaxCooldown - this.rushCooldown) / this.rushMaxCooldown;
                const isReady = this.rushCooldown <= 0;
                
                // Update mobile button
                if (isReady) {
                    this.rushButton.classList.remove('disabled');
                    this.rushCooldownRing.style.setProperty('--progress', '100%');
                } else {
                    this.rushButton.classList.add('disabled');
                    this.rushCooldownRing.style.setProperty('--progress', `${progress * 100}%`);
                }
                
                // Update desktop bar
                this.rushCooldownFill.style.setProperty('--cooldown-progress', `${progress * 100}%`);
            }

            updatePowerUps() {
                this.powerUps.forEach(powerUp => {
                    if (!powerUp.collected) {
                        powerUp.pulse += 0.15;
                        powerUp.glowIntensity = Math.sin(powerUp.pulse) * 0.3 + 0.7;
                    }
                });
            }

            updateActiveEffects() {
                // Update electric shield
                if (this.activeEffects.electricShield.active) {
                    this.activeEffects.electricShield.timer--;
                    if (this.activeEffects.electricShield.timer <= 0) {
                        this.activeEffects.electricShield.active = false;
                    } else {
                        // Stun enemies within shield radius
                        const shieldRadius = this.player.radius + 30;
                        this.enemies.forEach(enemy => {
                            const dx = this.player.x - enemy.x;
                            const dy = this.player.y - enemy.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < shieldRadius && !enemy.stunned) {
                                enemy.stunned = true;
                                enemy.stunnedTimer = 30; // 0.5 seconds
                                this.createParticles(enemy.x, enemy.y, '#FFD700');
                            }
                        });
                    }
                }
                
                // Update fire trail
                if (this.activeEffects.fireTrail.active) {
                    this.activeEffects.fireTrail.timer--;
                    if (this.activeEffects.fireTrail.timer <= 0) {
                        this.activeEffects.fireTrail.active = false;
                        this.activeEffects.fireTrail.trail = [];
                    } else {
                        // Add current position to trail
                        this.activeEffects.fireTrail.trail.push({
                            x: this.player.x,
                            y: this.player.y,
                            life: 180 // Trail segment lasts 3 seconds
                        });
                        
                        // Update trail segments
                        this.activeEffects.fireTrail.trail.forEach((segment, index) => {
                            segment.life--;
                            if (segment.life <= 0) {
                                this.activeEffects.fireTrail.trail.splice(index, 1);
                            }
                        });
                        
                        // Check enemies against fire trail
                        this.enemies.forEach((enemy, enemyIndex) => {
                            this.activeEffects.fireTrail.trail.forEach(segment => {
                                const dx = enemy.x - segment.x;
                                const dy = enemy.y - segment.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance < 15) {
                                    // Enemy touches fire trail - take damage and get absorbed
                                    enemy.health = 0; // Instant kill from fire
                                    this.score += 75;
                                    this.player.mass += 3;
                                    this.player.radius = Math.sqrt(this.player.mass) * 2;
                                    this.createParticles(enemy.x, enemy.y, '#FF4500');
                                    this.enemies.splice(enemyIndex, 1);
                                }
                            });
                        });
                    }
                }
            }

            checkPowerUpCollisions() {
                this.powerUps.forEach((powerUp, index) => {
                    if (powerUp.collected) return;
                    
                    const dx = this.player.x - powerUp.x;
                    const dy = this.player.y - powerUp.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.player.radius + powerUp.radius) {
                        // Collect power-up
                        powerUp.collected = true;
                        this.activatePowerUp(powerUp);
                        this.createParticles(powerUp.x, powerUp.y, powerUp.color);
                        this.powerUps.splice(index, 1);
                    }
                });
            }

            activatePowerUp(powerUp) {
                // Show discovery message if first time
                if (!this.discoveredPowerUps.has(powerUp.type)) {
                    this.discoveredPowerUps.add(powerUp.type);
                    this.showPowerNotification(0, 0, `DISCOVERED: ${powerUp.name}!`);
                }
                
                switch (powerUp.type) {
                    case 'electricShield':
                        this.activeEffects.electricShield.active = true;
                        this.activeEffects.electricShield.timer = 600; // 10 seconds
                        this.showPowerNotification(0, 0, 'ELECTRIC SHIELD ACTIVATED!');
                        break;
                        
                    case 'fireTrail':
                        this.activeEffects.fireTrail.active = true;
                        this.activeEffects.fireTrail.timer = 900; // 15 seconds
                        this.activeEffects.fireTrail.trail = [];
                        this.showPowerNotification(0, 0, 'FIRE TRAIL ACTIVATED!');
                        break;
                        
                    case 'rushRefill':
                        this.rushCooldown = 0;
                        this.updateRushButton();
                        this.showPowerNotification(0, 0, 'RUSH REFILLED!');
                        break;
                        
                    case 'healthBoost':
                        this.player.mass += 10;
                        this.player.radius = Math.sqrt(this.player.mass) * 2;
                        this.showPowerNotification(10, 0, 'HEALTH BOOST!');
                        break;
                        
                    case 'crossbowUpgrade':
                        // Temporary rapid fire
                        this.crossbowUpgradeTimer = 600; // 10 seconds
                        this.showPowerNotification(0, 0, 'CROSSBOW UPGRADED!');
                        break;
                        
                    case 'massShield':
                        // Protection from next 3 enemy hits
                        this.massShieldHits = 3;
                        this.showPowerNotification(0, 0, 'MASS SHIELD ACTIVE!');
                        break;
                }
            }

            gameLoop() {
                if (!this.gameRunning) return;

                this.updatePlayer();
                this.updateCrossbowDirection();
                this.updateRushCooldown();
                this.updatePowerUps();
                this.updateActiveEffects();
                this.updateCollectibles();
                this.updateEnemies();
                this.updateProjectiles();
                this.updateImmobilizedCollectibles();
                this.checkCollisions();
                this.checkEnemyCollisions();
                this.checkPowerUpCollisions();
                this.updateParticles();
                this.render();
                this.updateUI();

                requestAnimationFrame(() => this.gameLoop());
            }
            
            startGame() {
                this.startMenu.style.display = 'none';
                this.gameUI.style.display = 'block';
                
                // Show controls on mobile
                if (window.innerWidth < 768) {
                    this.thumbstickContainer.style.display = 'block';
                    this.shootButton.style.display = 'block';
                }
                
                this.gameStarted = true;
                this.gameRunning = true;
                this.gameLoop();
            }
        }

        // Initialize game when page loads
        window.addEventListener('load', () => {
            new MassCollectorGame();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            location.reload();
        });
    </script>
</body>
</html>