<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Katia's Training Room</title>
    <meta name="description" content="Training simulation for Katia Grim - absorption and crossbow skills">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(45deg, #2c1810, #3d2817);
            color: white;
            overflow: hidden;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            border: 2px solid #654321;
            background: #2a2a2a;
            box-shadow: 0 0 20px rgba(139, 69, 19, 0.5);
        }

        #startMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #0f3460;
            z-index: 100;
        }

        #startMenu h1 {
            color: #4fc3f7;
            margin-bottom: 20px;
            font-size: 2.5rem;
            text-shadow: 0 0 10px #4fc3f7;
        }

        #startMenu p {
            margin: 10px 0;
            font-size: 1.2rem;
            color: #b0bec5;
        }

        #readyBtn {
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            border: none;
            padding: 15px 30px;
            font-size: 1.5rem;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        #readyBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(79, 195, 247, 0.5);
        }

        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 50;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #0f3460;
        }

        #gameUI div {
            margin: 5px 0;
            font-size: 1.2rem;
        }

        .score {
            color: #4fc3f7;
        }

        .mass {
            color: #81c784;
        }

        /* Virtual thumb stick styles */
        #thumbstickContainer {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 100px;
            height: 100px;
            z-index: 100;
            touch-action: none;
            display: none;
        }

        #thumbstickBase {
            position: absolute;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            left: 10px;
            top: 10px;
        }

        #thumbstickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(79, 195, 247, 0.7);
            border-radius: 50%;
            border: 2px solid #4fc3f7;
            transform: translate(-50%, -50%);
            left: 50%;
            top: 50%;
            transition: transform 0.1s;
        }

        /* Shoot button styles */
        #shootButton {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: linear-gradient(45deg, #ff6b6b, #ff5252);
            border-radius: 50%;
            border: 2px solid #ff9e9e;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            touch-action: none;
            display: none;
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
        }

        #shootButton::before {
            content: "";
            position: absolute;
            width: 30px;
            height: 5px;
            background: #333;
            border-radius: 3px;
            transform: rotate(45deg);
            top: 25px;
            left: 25px;
        }

        #shootButton::after {
            content: "";
            position: absolute;
            width: 30px;
            height: 5px;
            background: #333;
            border-radius: 3px;
            transform: rotate(-45deg);
            top: 25px;
            left: 25px;
        }

        #shootButton.active {
            background: linear-gradient(45deg, #ff5252, #ff1744);
            box-shadow: 0 0 20px rgba(255, 82, 82, 0.8);
        }

        /* Power-up notifications */
        .power-notification {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            z-index: 1000 !important;
            pointer-events: none !important;
            padding: 10px 15px !important;
            background: linear-gradient(45deg, #4fc3f7, #29b6f6) !important;
            color: white !important;
            border-radius: 5px !important;
            font-family: 'Courier New', monospace !important;
            font-size: 14px !important;
            font-weight: bold !important;
            box-shadow: 0 4px 12px rgba(79, 195, 247, 0.4) !important;
            border: 1px solid rgba(255, 255, 255, 0.3) !important;
            animation: slideInFade 3s ease-out forwards !important;
            min-width: 120px !important;
            text-align: center !important;
        }

        @keyframes slideInFade {
            0% { 
                transform: translateX(100px) !important;
                opacity: 0 !important;
            }
            20% { 
                transform: translateX(0) !important;
                opacity: 1 !important;
            }
            80% { 
                opacity: 1 !important;
            }
            100% { 
                opacity: 0 !important;
            }
        }

        @media (max-width: 768px) {
            #startMenu h1 {
                font-size: 2rem;
            }
            
            #startMenu p {
                font-size: 1rem;
            }
            
            #gameUI {
                font-size: 1rem;
            }
            
            #thumbstickContainer, #shootButton {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="startMenu">
            <h1>KATIA'S TRAINING ROOM</h1>
            <p>ðŸŽ® Touch and drag to move</p>
            <p>ðŸ”µ Absorb energy orbs to grow stronger</p>
            <p>ðŸŽ¯ Some targets flee - use your crossbow!</p>
            <p>ðŸ“ˆ Master absorption techniques!</p>
            <button id="readyBtn">BEGIN TRAINING</button>
        </div>

        <div id="gameUI" style="display: none;">
            <div class="score">Score: <span id="score">0</span></div>
            <div class="mass">Mass: <span id="mass">10</span></div>
            <div class="room">Room: <span id="room">1</span></div>
            <div class="energy">Energy: <span id="energy">0</span>/<span id="energyRequired">100</span></div>
        </div>
        
        <!-- Virtual thumb stick -->
        <div id="thumbstickContainer">
            <div id="thumbstickBase"></div>
            <div id="thumbstickKnob"></div>
        </div>
        
        <!-- Shoot button -->
        <div id="shootButton"></div>
    </div>

    <script>
        class MassCollectorGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.startMenu = document.getElementById('startMenu');
                this.gameUI = document.getElementById('gameUI');
                
                // Control elements
                this.thumbstickContainer = document.getElementById('thumbstickContainer');
                this.thumbstickKnob = document.getElementById('thumbstickKnob');
                this.shootButton = document.getElementById('shootButton');
                
                this.setupCanvas();
                this.initGame();
                this.setupControls();
                
                document.getElementById('readyBtn').addEventListener('click', () => this.startGame());
            }

            setupCanvas() {
                const container = document.getElementById('gameContainer');
                this.canvas.width = Math.min(window.innerWidth - 20, 800);
                this.canvas.height = Math.min(window.innerHeight - 20, 600);
                
                // Adjust for mobile
                if (window.innerWidth < 768) {
                    this.canvas.width = window.innerWidth - 10;
                    this.canvas.height = window.innerHeight - 10;
                }
            }

            showPowerNotification(mass, score, customMessage = null) {
                // Remove any existing notifications
                const existingNotifications = document.querySelectorAll('.power-notification');
                existingNotifications.forEach(notification => {
                    document.body.removeChild(notification);
                });

                // Create new notification
                const notification = document.createElement('div');
                notification.className = 'power-notification';
                
                let message = '';
                if (customMessage) {
                    message = customMessage;
                } else if (mass < 0) {
                    message = `DAMAGE! ${mass}`;
                } else if (mass >= 5) {
                    message = `MASS SURGE! +${Math.floor(mass)}`;
                } else if (score >= 50) {
                    message = `BIG SCORE! +${score}`;
                } else {
                    message = `ENERGY +${score}`;
                }
                
                notification.textContent = message;
                document.body.appendChild(notification);

                // Remove after animation completes
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 3000);
            }

            initGame() {
                this.gameStarted = false;
                this.gameRunning = false;
                
                // Player properties
                this.player = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    radius: 15,
                    mass: 10,
                    color: '#4fc3f7',
                    targetX: this.canvas.width / 2,
                    targetY: this.canvas.height / 2,
                    velocity: { x: 0, y: 0 },
                    maxSpeed: 5,
                    crossbowAngle: 0,
                    directionX: 1,  // Default to moving right
                    directionY: 0   // Initially not moving vertically
                };

                // Game state
                this.score = 0;
                this.collectibles = [];
                this.particles = [];
                this.projectiles = [];
                this.enemies = [];
                
                // Room progression
                this.currentRoom = 1;
                this.energyRequired = 100; // Energy needed to advance to next room
                this.totalEnergy = 0; // Total energy collected
                
                // Thumbstick properties
                this.thumbstickActive = false;
                this.thumbstickPosition = { x: 0, y: 0 };
                this.thumbstickBasePosition = { 
                    x: this.thumbstickContainer.offsetLeft + this.thumbstickContainer.offsetWidth / 2,
                    y: this.thumbstickContainer.offsetTop + this.thumbstickContainer.offsetHeight / 2
                };
                this.thumbstickRadius = 40;
                
                this.generateCollectibles();
                this.generateEnemies();
            }

            generateCollectibles() {
                this.collectibles = [];
                // DCC-themed energy crystal colors
                const colors = ['#8A2BE2', '#FF4500', '#32CD32', '#FFD700', '#DC143C', '#4169E1', '#FF69B4'];
                
                for (let i = 0; i < 25; i++) {
                    let x, y, attempts = 0;
                    
                    // Ensure collectibles don't spawn too close to player
                    do {
                        x = Math.random() * (this.canvas.width - 40) + 20;
                        y = Math.random() * (this.canvas.height - 40) + 20;
                        attempts++;
                    } while (
                        attempts < 50 && 
                        Math.sqrt((x - this.player.x) ** 2 + (y - this.player.y) ** 2) < 100
                    );

                    // Randomly make some collectibles flee
                    const isFleeing = Math.random() < 0.3;
                    
                    this.collectibles.push({
                        x: x,
                        y: y,
                        radius: Math.random() * 8 + 5,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        mass: Math.random() * 5 + 2,
                        pulse: Math.random() * Math.PI * 2,
                        collected: false,
                        fleeing: isFleeing,
                        fleeTimer: 0,
                        immobilized: false,
                        immobilizeTimer: 0
                    });
                }
            }

            generateEnemies() {
                this.enemies = [];
                const enemyCount = Math.min(3 + this.currentRoom, 8); // More enemies in higher rooms
                
                for (let i = 0; i < enemyCount; i++) {
                    let x, y, attempts = 0;
                    
                    // Spawn enemies away from player
                    do {
                        x = Math.random() * (this.canvas.width - 60) + 30;
                        y = Math.random() * (this.canvas.height - 60) + 30;
                        attempts++;
                    } while (
                        attempts < 50 && 
                        Math.sqrt((x - this.player.x) ** 2 + (y - this.player.y) ** 2) < 200
                    );
                    
                    // Different enemy types
                    const enemyType = Math.random();
                    let type, color, speed, health, behavior;
                    
                    if (enemyType < 0.4) {
                        // Chaser - direct pursuit
                        type = 'chaser';
                        color = '#FF4500'; // Orange-red
                        speed = 1.5;
                        health = 2;
                        behavior = 'chase';
                    } else if (enemyType < 0.7) {
                        // Ambusher - tries to flank
                        type = 'ambusher';
                        color = '#8B008B'; // Dark magenta
                        speed = 2;
                        health = 1;
                        behavior = 'flank';
                    } else {
                        // Guardian - protects crystals, slower but tougher
                        type = 'guardian';
                        color = '#2F4F4F'; // Dark slate gray
                        speed = 1;
                        health = 4;
                        behavior = 'guard';
                    }
                    
                    this.enemies.push({
                        x: x,
                        y: y,
                        radius: 12,
                        type: type,
                        color: color,
                        speed: speed,
                        health: health,
                        maxHealth: health,
                        behavior: behavior,
                        targetX: x,
                        targetY: y,
                        angle: 0,
                        stunned: false,
                        stunnedTimer: 0,
                        lastDamageTime: 0
                    });
                }
            }

            setupControls() {
                // Touch controls for thumbstick
                this.thumbstickContainer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    this.thumbstickActive = true;
                    this.updateThumbstick(e.touches[0]);
                });

                this.thumbstickContainer.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning || !this.thumbstickActive) return;
                    
                    this.updateThumbstick(e.touches[0]);
                });

                this.thumbstickContainer.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.thumbstickActive = false;
                    this.resetThumbstick();
                });

                this.thumbstickContainer.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.thumbstickActive = false;
                    this.resetThumbstick();
                });

                // Shoot button controls
                this.shootButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    this.shootButton.classList.add('active');
                    this.shootCrossbow();
                });

                this.shootButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.shootButton.classList.remove('active');
                });

                this.shootButton.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.shootButton.classList.remove('active');
                });

                // Mouse click to shoot for desktop
                this.canvas.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning || e.button !== 0) return; // Only left click
                    
                    this.shootCrossbow();
                });

                // Mouse controls for desktop
                this.canvas.addEventListener('mousemove', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    this.player.targetX = e.clientX - rect.left;
                    this.player.targetY = e.clientY - rect.top;
                });

                // Touch controls for canvas (fallback)
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    this.player.targetX = touch.clientX - rect.left;
                    this.player.targetY = touch.clientY - rect.top;
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning) return;
                    
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    this.player.targetX = touch.clientX - rect.left;
                    this.player.targetY = touch.clientY - rect.top;
                });

                // Prevent context menu on touch
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            updateThumbstick(touch) {
                const rect = this.thumbstickContainer.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                // Calculate distance from center
                const centerX = this.thumbstickContainer.offsetWidth / 2;
                const centerY = this.thumbstickContainer.offsetHeight / 2;
                const dx = touchX - centerX;
                const dy = touchY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Limit to thumbstick radius
                if (distance > this.thumbstickRadius) {
                    const angle = Math.atan2(dy, dx);
                    this.thumbstickPosition.x = Math.cos(angle) * this.thumbstickRadius;
                    this.thumbstickPosition.y = Math.sin(angle) * this.thumbstickRadius;
                } else {
                    this.thumbstickPosition.x = dx;
                    this.thumbstickPosition.y = dy;
                }
                
                // Update knob position
                this.thumbstickKnob.style.transform = `translate(-50%, -50%) translate(${this.thumbstickPosition.x}px, ${this.thumbstickPosition.y}px)`;
                
                // Update player target position based on thumbstick
                const maxDistance = this.thumbstickRadius;
                const moveX = this.thumbstickPosition.x / maxDistance;
                const moveY = this.thumbstickPosition.y / maxDistance;
                
                this.player.targetX = this.player.x + moveX * 100;
                this.player.targetY = this.player.y + moveY * 100;
            }
            
            resetThumbstick() {
                this.thumbstickPosition = { x: 0, y: 0 };
                this.thumbstickKnob.style.transform = 'translate(-50%, -50%)';
                this.player.targetX = this.player.x;
                this.player.targetY = this.player.y;
            }
            
            updateCrossbowDirection() {
                this.player.crossbowAngle = Math.atan2(this.player.directionY, this.player.directionX);
            }
            
            shootCrossbow() {
                if (!this.gameRunning) return;
                
                // Create a projectile
                const speed = 10;
                const offsetX = Math.cos(this.player.crossbowAngle) * (this.player.radius + 5);
                const offsetY = Math.sin(this.player.crossbowAngle) * (this.player.radius + 5);
                
                this.projectiles.push({
                    x: this.player.x + offsetX,
                    y: this.player.y + offsetY,
                    vx: Math.cos(this.player.crossbowAngle) * speed,
                    vy: Math.sin(this.player.crossbowAngle) * speed,
                    radius: 4,
                    color: '#ffcc00',
                    life: 60 // Will disappear after 60 frames
                });
            }

            updatePlayer() {
                const dx = this.player.targetX - this.player.x;
                const dy = this.player.targetY - this.player.y;
                
                // Calculate direction and distance
                const distance = Math.sqrt(dx * dx + dy * dy);
                const directionX = dx / distance || 0;
                const directionY = dy / distance || 0;
                
                // Store movement direction (if moving significantly)
                if (distance > 5) {
                    this.player.directionX = directionX;
                    this.player.directionY = directionY;
                }
                
                // Smooth movement with speed based on mass
                const speed = Math.max(0.5, 3 - (this.player.mass / 50));
                this.player.x += directionX * speed;
                this.player.y += directionY * speed;

                // Keep player in bounds
                this.player.x = Math.max(this.player.radius, 
                    Math.min(this.canvas.width - this.player.radius, this.player.x));
                this.player.y = Math.max(this.player.radius, 
                    Math.min(this.canvas.height - this.player.radius, this.player.y));
            }

            updateCollectibles() {
                this.collectibles.forEach(collectible => {
                    if (collectible.collected || collectible.immobilized) return;
                    
                    // Update flee timer if active
                    if (collectible.fleeTimer > 0) {
                        collectible.fleeTimer--;
                    }
                    
                    // Fleeing behavior
                    if (collectible.fleeing && collectible.fleeTimer <= 0) {
                        const dx = collectible.x - this.player.x;
                        const dy = collectible.y - this.player.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Only flee if player is close enough
                        if (distance < 150) {
                            const fleeSpeed = 0.8;
                            const fleeDirectionX = dx / distance;
                            const fleeDirectionY = dy / distance;
                            
                            collectible.x += fleeDirectionX * fleeSpeed;
                            collectible.y += fleeDirectionY * fleeSpeed;
                            
                            // Keep collectible in bounds
                            collectible.x = Math.max(collectible.radius, 
                                Math.min(this.canvas.width - collectible.radius, collectible.x));
                            collectible.y = Math.max(collectible.radius, 
                                Math.min(this.canvas.height - collectible.radius, collectible.y));
                        }
                    }
                });
            }
            
            updateProjectiles() {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const projectile = this.projectiles[i];
                    
                    // Move projectile
                    projectile.x += projectile.vx;
                    projectile.y += projectile.vy;
                    projectile.life--;
                    
                    // Check if projectile is out of bounds
                    if (
                        projectile.x < -50 || 
                        projectile.x > this.canvas.width + 50 ||
                        projectile.y < -50 || 
                        projectile.y > this.canvas.height + 50 ||
                        projectile.life <= 0
                    ) {
                        this.projectiles.splice(i, 1);
                        continue;
                    }
                    
                    // Check collision with collectibles
                    this.collectibles.forEach(collectible => {
                        if (collectible.collected || collectible.immobilized) return;
                        
                        const dx = projectile.x - collectible.x;
                        const dy = projectile.y - collectible.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < projectile.radius + collectible.radius) {
                            // Hit! Immobilize the collectible
                            collectible.immobilized = true;
                            collectible.immobilizeTimer = 120; // 2 seconds at 60fps
                            
                            // Create hit particles
                            this.createParticles(collectible.x, collectible.y, '#ffcc00');
                            
                            // Remove projectile
                            this.projectiles.splice(i, 1);
                            return;
                        }
                    });
                }
            }

            updateEnemies() {
                this.enemies.forEach((enemy, index) => {
                    // Handle stun timer
                    if (enemy.stunned) {
                        enemy.stunnedTimer--;
                        if (enemy.stunnedTimer <= 0) {
                            enemy.stunned = false;
                        }
                        return; // Don't move while stunned
                    }
                    
                    // Different AI behaviors
                    if (enemy.behavior === 'chase') {
                        // Direct chase
                        const dx = this.player.x - enemy.x;
                        const dy = this.player.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            enemy.x += (dx / distance) * enemy.speed;
                            enemy.y += (dy / distance) * enemy.speed;
                        }
                    } else if (enemy.behavior === 'flank') {
                        // Try to move to player's side
                        const dx = this.player.x - enemy.x;
                        const dy = this.player.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 50) {
                            // Move toward player
                            enemy.x += (dx / distance) * enemy.speed;
                            enemy.y += (dy / distance) * enemy.speed;
                        } else {
                            // Circle around player
                            const angle = Math.atan2(dy, dx) + Math.PI / 2;
                            enemy.x += Math.cos(angle) * enemy.speed;
                            enemy.y += Math.sin(angle) * enemy.speed;
                        }
                    } else if (enemy.behavior === 'guard') {
                        // Protect nearest crystal cluster
                        let nearestCrystal = null;
                        let nearestDistance = Infinity;
                        
                        this.collectibles.forEach(collectible => {
                            if (!collectible.collected) {
                                const dist = Math.sqrt((enemy.x - collectible.x) ** 2 + (enemy.y - collectible.y) ** 2);
                                if (dist < nearestDistance) {
                                    nearestDistance = dist;
                                    nearestCrystal = collectible;
                                }
                            }
                        });
                        
                        if (nearestCrystal) {
                            const playerDist = Math.sqrt((this.player.x - nearestCrystal.x) ** 2 + (this.player.y - nearestCrystal.y) ** 2);
                            const enemyDist = Math.sqrt((enemy.x - nearestCrystal.x) ** 2 + (enemy.y - nearestCrystal.y) ** 2);
                            
                            if (playerDist < 100 && enemyDist > 30) {
                                // Player near crystal, move to intercept
                                const dx = this.player.x - enemy.x;
                                const dy = this.player.y - enemy.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance > 0) {
                                    enemy.x += (dx / distance) * enemy.speed;
                                    enemy.y += (dy / distance) * enemy.speed;
                                }
                            } else if (enemyDist > 40) {
                                // Move closer to crystal
                                const dx = nearestCrystal.x - enemy.x;
                                const dy = nearestCrystal.y - enemy.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance > 0) {
                                    enemy.x += (dx / distance) * enemy.speed * 0.5;
                                    enemy.y += (dy / distance) * enemy.speed * 0.5;
                                }
                            }
                        }
                    }
                    
                    // Keep enemies in bounds
                    enemy.x = Math.max(enemy.radius, Math.min(this.canvas.width - enemy.radius, enemy.x));
                    enemy.y = Math.max(enemy.radius, Math.min(this.canvas.height - enemy.radius, enemy.y));
                });
            }

            checkEnemyCollisions() {
                // Check projectile hits on enemies
                this.projectiles.forEach((projectile, projIndex) => {
                    this.enemies.forEach((enemy, enemyIndex) => {
                        if (enemy.stunned) return;
                        
                        const dx = projectile.x - enemy.x;
                        const dy = projectile.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < projectile.radius + enemy.radius) {
                            // Hit enemy with crossbow
                            enemy.health--;
                            enemy.lastDamageTime = Date.now();
                            
                            // Create hit particles
                            this.createParticles(enemy.x, enemy.y, '#ff0000');
                            
                            // Remove projectile
                            this.projectiles.splice(projIndex, 1);
                            
                            if (enemy.health <= 0) {
                                // Enemy defeated
                                this.score += 50;
                                this.createParticles(enemy.x, enemy.y, enemy.color);
                                this.enemies.splice(enemyIndex, 1);
                            } else {
                                // Stun enemy briefly
                                enemy.stunned = true;
                                enemy.stunnedTimer = 30; // 0.5 seconds
                            }
                            return;
                        }
                    });
                });
                
                // Check player collision with enemies
                this.enemies.forEach((enemy, index) => {
                    const dx = this.player.x - enemy.x;
                    const dy = this.player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.player.radius + enemy.radius) {
                        // Player touched by enemy - take damage
                        this.player.mass = Math.max(5, this.player.mass - 2);
                        this.player.radius = Math.sqrt(this.player.mass) * 2;
                        
                        // Push enemy away
                        const pushForce = 20;
                        const angle = Math.atan2(dy, dx);
                        enemy.x -= Math.cos(angle) * pushForce;
                        enemy.y -= Math.sin(angle) * pushForce;
                        
                        // Brief stun for enemy
                        enemy.stunned = true;
                        enemy.stunnedTimer = 60; // 1 second
                        
                        // Damage notification
                        this.showPowerNotification(-2, -20);
                    }
                });
            }
            
            updateImmobilizedCollectibles() {
                this.collectibles.forEach(collectible => {
                    if (collectible.immobilized) {
                        collectible.immobilizeTimer--;
                        
                        if (collectible.immobilizeTimer <= 0) {
                            collectible.immobilized = false;
                        }
                    }
                });
            }

            checkCollisions() {
                this.collectibles.forEach((collectible, index) => {
                    if (collectible.collected) return;

                    const dx = this.player.x - collectible.x;
                    const dy = this.player.y - collectible.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.player.radius + collectible.radius) {
                        // Collect the item
                        collectible.collected = true;
                        const scoreGain = Math.floor(collectible.mass * 10);
                        const energyGain = Math.floor(collectible.mass * 5);
                        this.score += scoreGain;
                        this.totalEnergy += energyGain;
                        this.player.mass += collectible.mass;
                        this.player.radius = Math.sqrt(this.player.mass) * 2;

                        // Show power-up notification
                        this.showPowerNotification(collectible.mass, scoreGain);

                        // Create particles
                        this.createParticles(collectible.x, collectible.y, collectible.color);

                        // Remove collectible
                        this.collectibles.splice(index, 1);

                        // Generate new collectible
                        if (this.collectibles.length < 20) {
                            setTimeout(() => this.addNewCollectible(), 500);
                        }
                    }
                });
            }

            addNewCollectible() {
                // DCC-themed energy crystal colors
                const colors = ['#8A2BE2', '#FF4500', '#32CD32', '#FFD700', '#DC143C', '#4169E1', '#FF69B4'];
                let x, y, attempts = 0;
                
                do {
                    x = Math.random() * (this.canvas.width - 40) + 20;
                    y = Math.random() * (this.canvas.height - 40) + 20;
                    attempts++;
                } while (
                    attempts < 50 && 
                    Math.sqrt((x - this.player.x) ** 2 + (y - this.player.y) ** 2) < 150
                );

                // Randomly make some collectibles flee
                const isFleeing = Math.random() < 0.3;
                
                this.collectibles.push({
                    x: x,
                    y: y,
                    radius: Math.random() * 8 + 5,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    mass: Math.random() * 5 + 2,
                    pulse: Math.random() * Math.PI * 2,
                    collected: false,
                    fleeing: isFleeing,
                    fleeTimer: 0,
                    immobilized: false,
                    immobilizeTimer: 0
                });
            }

            createParticles(x, y, color) {
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        color: color,
                        life: 30,
                        maxLife: 30
                    });
                }
            }

            updateParticles() {
                this.particles.forEach((particle, index) => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.98;
                    particle.vy *= 0.98;
                    particle.life--;

                    if (particle.life <= 0) {
                        this.particles.splice(index, 1);
                    }
                });
            }

            drawStoneFloor() {
                const tileSize = 60;
                for (let x = 0; x < this.canvas.width + tileSize; x += tileSize) {
                    for (let y = 0; y < this.canvas.height + tileSize; y += tileSize) {
                        // Draw stone tile
                        this.ctx.fillStyle = '#3a3a3a';
                        this.ctx.fillRect(x, y, tileSize - 2, tileSize - 2);
                        
                        // Add some variation to tiles
                        const variation = Math.sin(x * 0.01 + y * 0.01) * 10;
                        this.ctx.fillStyle = `rgba(${50 + variation}, ${50 + variation}, ${50 + variation}, 0.3)`;
                        this.ctx.fillRect(x + 5, y + 5, tileSize - 12, tileSize - 12);
                        
                        // Dark grout lines
                        this.ctx.strokeStyle = '#1a1a1a';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(x, y, tileSize - 2, tileSize - 2);
                    }
                }
            }

            render() {
                // Clear canvas with dark stone color
                this.ctx.fillStyle = '#2a2a2a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw stone floor tiles
                this.drawStoneFloor();

                // Draw grid
                this.ctx.strokeStyle = 'rgba(15, 52, 96, 0.3)';
                this.ctx.lineWidth = 1;
                for (let x = 0; x < this.canvas.width; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let y = 0; y < this.canvas.height; y += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }

                // Draw projectiles
                this.projectiles.forEach(projectile => {
                    this.ctx.beginPath();
                    this.ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = projectile.color;
                    this.ctx.fill();
                    
                    // Draw bolt tail
                    this.ctx.beginPath();
                    this.ctx.moveTo(projectile.x, projectile.y);
                    this.ctx.lineTo(
                        projectile.x - Math.cos(this.player.crossbowAngle) * 10,
                        projectile.y - Math.sin(this.player.crossbowAngle) * 10
                    );
                    this.ctx.strokeStyle = 'rgba(255, 204, 0, 0.7)';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });

                // Draw collectibles (Energy Crystals)
                this.collectibles.forEach(collectible => {
                    if (collectible.collected) return;
                    
                    this.drawEnergyCrystal(collectible);
                });

                // Draw enemies
                this.enemies.forEach(enemy => {
                    this.drawEnemy(enemy);
                });

                // Draw particles
                this.particles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.fillStyle = particle.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, 3 * alpha, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // Draw player (Katia/Tatis)
                this.drawKatiaSprite();
                
                // Draw crossbow
                this.drawCrossbow();
            }

            drawKatiaSprite() {
                const x = this.player.x;
                const y = this.player.y;
                const radius = this.player.radius;
                
                // Draw muscular body (larger, darker skin tone)
                this.ctx.fillStyle = '#8B4513'; // Dark skin tone
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius * 0.9, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw body highlight for muscle definition
                this.ctx.fillStyle = '#A0522D';
                this.ctx.beginPath();
                this.ctx.arc(x - radius * 0.3, y - radius * 0.3, radius * 0.4, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw purple mohawk (distinctive purple hair in spikes)
                this.ctx.fillStyle = '#8A2BE2'; // Purple
                this.ctx.beginPath();
                // Central spike
                this.ctx.arc(x, y - radius * 0.8, radius * 0.3, 0, Math.PI * 2);
                this.ctx.fill();
                // Left spike
                this.ctx.beginPath();
                this.ctx.arc(x - radius * 0.4, y - radius * 0.7, radius * 0.25, 0, Math.PI * 2);
                this.ctx.fill();
                // Right spike
                this.ctx.beginPath();
                this.ctx.arc(x + radius * 0.4, y - radius * 0.7, radius * 0.25, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw energy aura (represents her absorption powers)
                this.ctx.strokeStyle = 'rgba(138, 43, 226, 0.5)'; // Purple glow
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius + 5, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Pulsing inner aura
                const pulseSize = Math.sin(Date.now() * 0.005) * 3;
                this.ctx.strokeStyle = 'rgba(138, 43, 226, 0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius + pulseSize, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            drawCrossbow() {
                const x = this.player.x;
                const y = this.player.y;
                const angle = this.player.crossbowAngle;
                const length = this.player.radius + 12;
                
                // Crossbow stock (main body)
                this.ctx.strokeStyle = '#8B4513'; // Dark brown
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(
                    x + Math.cos(angle) * length,
                    y + Math.sin(angle) * length
                );
                this.ctx.stroke();
                
                // Crossbow arms (horizontal part)
                const armLength = 8;
                const tipX = x + Math.cos(angle) * length;
                const tipY = y + Math.sin(angle) * length;
                
                // Left arm
                this.ctx.strokeStyle = '#654321'; // Darker brown
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(
                    tipX + Math.cos(angle + Math.PI/2) * armLength,
                    tipY + Math.sin(angle + Math.PI/2) * armLength
                );
                this.ctx.lineTo(
                    tipX + Math.cos(angle - Math.PI/2) * armLength,
                    tipY + Math.sin(angle - Math.PI/2) * armLength
                );
                this.ctx.stroke();
                
                // Crossbow string
                this.ctx.strokeStyle = 'rgba(200, 200, 200, 0.8)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(
                    tipX + Math.cos(angle + Math.PI/2) * armLength * 0.8,
                    tipY + Math.sin(angle + Math.PI/2) * armLength * 0.8
                );
                this.ctx.lineTo(
                    tipX + Math.cos(angle - Math.PI/2) * armLength * 0.8,
                    tipY + Math.sin(angle - Math.PI/2) * armLength * 0.8
                );
                this.ctx.stroke();
                
                // Trigger mechanism
                this.ctx.fillStyle = '#CD853F'; // Light brown
                this.ctx.beginPath();
                this.ctx.arc(
                    x + Math.cos(angle) * (length * 0.7),
                    y + Math.sin(angle) * (length * 0.7),
                    2,
                    0,
                    Math.PI * 2
                );
                this.ctx.fill();
            }

            drawEnergyCrystal(collectible) {
                const x = collectible.x;
                const y = collectible.y;
                collectible.pulse += 0.1;
                const pulseIntensity = Math.sin(collectible.pulse) * 0.3 + 0.7;
                const radius = collectible.radius;
                
                // Draw crystal facets (diamond-like shape)
                this.ctx.save();
                this.ctx.translate(x, y);
                
                // Main crystal body
                this.ctx.fillStyle = collectible.color;
                this.ctx.globalAlpha = pulseIntensity;
                this.ctx.beginPath();
                // Create diamond/crystal shape
                this.ctx.moveTo(0, -radius);
                this.ctx.lineTo(radius * 0.7, -radius * 0.3);
                this.ctx.lineTo(radius * 0.7, radius * 0.3);
                this.ctx.lineTo(0, radius);
                this.ctx.lineTo(-radius * 0.7, radius * 0.3);
                this.ctx.lineTo(-radius * 0.7, -radius * 0.3);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Crystal highlights
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                this.ctx.globalAlpha = pulseIntensity * 0.8;
                this.ctx.beginPath();
                this.ctx.moveTo(0, -radius * 0.8);
                this.ctx.lineTo(radius * 0.4, -radius * 0.2);
                this.ctx.lineTo(0, 0);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Energy glow
                this.ctx.globalAlpha = pulseIntensity * 0.5;
                this.ctx.strokeStyle = collectible.color;
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, radius + 3, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Immobilized effect (crossbow hit)
                if (collectible.immobilized) {
                    this.ctx.globalAlpha = 1;
                    this.ctx.strokeStyle = 'rgba(255, 204, 0, 0.9)';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius + 5, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Draw crossbow bolt stuck in crystal
                    this.ctx.strokeStyle = '#8B4513';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(-radius * 0.3, -radius * 0.3);
                    this.ctx.lineTo(radius * 0.3, radius * 0.3);
                    this.ctx.stroke();
                }
                
                this.ctx.restore();
            }

            drawEnemy(enemy) {
                const x = enemy.x;
                const y = enemy.y;
                const radius = enemy.radius;
                
                // Flash red when damaged
                const timeSinceHit = Date.now() - enemy.lastDamageTime;
                const isFlashing = timeSinceHit < 300 && Math.floor(timeSinceHit / 50) % 2 === 0;
                
                this.ctx.save();
                this.ctx.translate(x, y);
                
                // Main enemy body based on type
                if (enemy.type === 'chaser') {
                    // Aggressive angular shape
                    this.ctx.fillStyle = isFlashing ? '#FF6666' : enemy.color;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, -radius);
                    this.ctx.lineTo(radius * 0.8, -radius * 0.3);
                    this.ctx.lineTo(radius * 0.8, radius * 0.3);
                    this.ctx.lineTo(0, radius);
                    this.ctx.lineTo(-radius * 0.8, radius * 0.3);
                    this.ctx.lineTo(-radius * 0.8, -radius * 0.3);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // Aggressive eyes
                    this.ctx.fillStyle = '#FF0000';
                    this.ctx.beginPath();
                    this.ctx.arc(-radius * 0.3, -radius * 0.2, 2, 0, Math.PI * 2);
                    this.ctx.arc(radius * 0.3, -radius * 0.2, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                } else if (enemy.type === 'ambusher') {
                    // Sleek, fast shape
                    this.ctx.fillStyle = isFlashing ? '#DD44DD' : enemy.color;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Speed lines
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    this.ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        const angle = (i * Math.PI * 2) / 3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(Math.cos(angle) * radius * 0.5, Math.sin(angle) * radius * 0.5);
                        this.ctx.lineTo(Math.cos(angle) * radius * 0.8, Math.sin(angle) * radius * 0.8);
                        this.ctx.stroke();
                    }
                    
                } else if (enemy.type === 'guardian') {
                    // Heavy, defensive shape
                    this.ctx.fillStyle = isFlashing ? '#666666' : enemy.color;
                    this.ctx.fillRect(-radius, -radius * 0.8, radius * 2, radius * 1.6);
                    
                    // Armor plating
                    this.ctx.strokeStyle = '#888888';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(-radius, -radius * 0.8, radius * 2, radius * 1.6);
                    
                    // Shield symbol
                    this.ctx.strokeStyle = '#AAAAAA';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius * 0.4, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                // Health bar
                if (enemy.health < enemy.maxHealth) {
                    const barWidth = radius * 2;
                    const barHeight = 4;
                    const healthPercent = enemy.health / enemy.maxHealth;
                    
                    // Background
                    this.ctx.fillStyle = '#333333';
                    this.ctx.fillRect(-barWidth / 2, -radius - 10, barWidth, barHeight);
                    
                    // Health
                    this.ctx.fillStyle = '#FF0000';
                    this.ctx.fillRect(-barWidth / 2, -radius - 10, barWidth * healthPercent, barHeight);
                }
                
                // Stun effect
                if (enemy.stunned) {
                    this.ctx.strokeStyle = '#FFFF00';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius + 3, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Stun stars
                    for (let i = 0; i < 3; i++) {
                        const angle = (Date.now() * 0.01 + i * Math.PI * 2 / 3);
                        const starX = Math.cos(angle) * (radius + 8);
                        const starY = Math.sin(angle) * (radius + 8);
                        this.ctx.fillStyle = '#FFFF00';
                        this.ctx.beginPath();
                        this.ctx.arc(starX, starY, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
                
                this.ctx.restore();
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('mass').textContent = Math.floor(this.player.mass);
                document.getElementById('room').textContent = this.currentRoom;
                document.getElementById('energy').textContent = this.totalEnergy;
                document.getElementById('energyRequired').textContent = this.energyRequired;
                
                // Check for room advancement
                if (this.totalEnergy >= this.energyRequired) {
                    this.advanceToNextRoom();
                }
            }

            advanceToNextRoom() {
                this.currentRoom++;
                this.energyRequired = Math.floor(this.energyRequired * 1.5); // Increase requirement by 50%
                this.totalEnergy = 0; // Reset energy for new room
                
                // Show room advancement notification
                this.showPowerNotification(0, 0, `ROOM ${this.currentRoom} UNLOCKED!`);
                
                // Generate new enemies and collectibles for the new room
                this.generateEnemies();
                this.generateCollectibles();
                
                // Slight player power boost for advancing
                this.player.mass += 5;
                this.player.radius = Math.sqrt(this.player.mass) * 2;
            }

            gameLoop() {
                if (!this.gameRunning) return;

                this.updatePlayer();
                this.updateCrossbowDirection();
                this.updateCollectibles();
                this.updateEnemies();
                this.updateProjectiles();
                this.updateImmobilizedCollectibles();
                this.checkCollisions();
                this.checkEnemyCollisions();
                this.updateParticles();
                this.render();
                this.updateUI();

                requestAnimationFrame(() => this.gameLoop());
            }
            
            startGame() {
                this.startMenu.style.display = 'none';
                this.gameUI.style.display = 'block';
                
                // Show controls on mobile
                if (window.innerWidth < 768) {
                    this.thumbstickContainer.style.display = 'block';
                    this.shootButton.style.display = 'block';
                }
                
                this.gameStarted = true;
                this.gameRunning = true;
                this.gameLoop();
            }
        }

        // Initialize game when page loads
        window.addEventListener('load', () => {
            new MassCollectorGame();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            location.reload();
        });
    </script>
</body>
</html>